# -*- coding: utf-8 -*-
"""Bioinformatics_#2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tRhn4C8YJnnicoAbbb3a4E5eIa_42bMf

# Finding the site of the Ori within a string of DNA.

* The 'Ori' is the origin of replication, it is the point in a DNA string where the strands split and the replication enzymes start to copy the DNA.
"""

genome = "GCATACACTTCCCAGTAGGTACTG"


count = []

for i in range( len( genome ) ):

  if i == 0:
    if genome[ i ] == "G":

      count.append( 1 )

    elif genome[i] == "C":

      count.append( -1 )

    else:

      count.append( 0 )
    continue


  if genome[ i ] == "G":
    
    count.append( count[ i - 1 ] + 1 )
  
  elif genome[ i ] == "C":

    count.append( count[ i - 1 ] - 1 )

  else:

    count.append( count[ i - 1 ] )



print( count )

print( min( count ))

print( count.index( max(count) ) )

"""# Finding the Hamming distance between two snippets of DNA."""

def HammingDistance( fg, sg ):


  distance = 0

  for i in range( len( fg ) ):


    if fg[ i ] != sg[ i ]:
      distance += 1

  return distance

"""# Finding all the kmers(segments of DNA of length k), which are a Hamming disatnce d away within a string of DNA."""

genome = "CATGCCATTCGCATTGTCCCAGTGA"

kmer = "CCC"

d = 2


g_length = len( genome )

r_length = len( kmer )

length = g_length - (r_length - 1)


count = []

for i in range( length ):

  #print( genome[ i:(i + r_length) ], repeated )

  if HammingDistance( genome[ i:(i + r_length) ], kmer ) <= d:

    count.append( i )


print( count )

print( len( count ) )

for i in count:

  print( i )

"""# Finding all k-mers within a DNA string with Hamming distance of at most d between the k-mers."""

genome = "CTTGAGGGCTTGACTCCTTCTTTGTGACTTCTTCTTGGGTGTCTCTGTTGTGGGCTCTGTGGGGATGTCTTTGTTGTCTTTGTGGGGATGTCTCGGGGAGACTCTGTCTTCTCGATGTCTCGGGCTTCTCCTCCTTTGTGAGGGGGGGGGCTTGGGCTCGAGGGCTTGAGAGGGGGGCTCTGTTGTGACTTCTCCTTCTC"

d = 2

k = 6

kmer = ""

freq_table = {}

new_freq_table = {}

alphabet = [ "A", "T", "C", "G" ]

dictionary = ["A" * k]

num = list( "0" * k )

len_alpha = len( alphabet )

g_length = len( genome )




def add( num, position ):

  if int( num[ position ] ) + 1 > len_alpha - 1:

    if position + 1 > k-1:
      return

    num[ position ] = '0'

    add( num, position + 1 )
    return

  num[ position ] = str( int( num[ position ] ) + 1  )

  kmer = []

  for i in range( len( num ) ):

    kmer.append( alphabet[int(num[i])] )

  dictionary.append( "".join(kmer) )
  


for i in range( len_alpha ** k ):

  if int( num[ 0 ] ) + 1 > len_alpha - 1:

    num[ 0 ] = '0'

    add( num, 1 )
  
  else:

    num[ 0 ] = str( int( num[ 0 ] ) + 1  )

    kmer = []

    for i in range( len( num ) ):

      kmer.append( alphabet[int(num[i])] )

    dictionary.append( "".join(kmer) )



for i in range( g_length - k + 1 ):


  # Add the k-mer if it is not in the frequency table.
  if genome[ i:(i + k) ] not in freq_table.keys():

    freq_table[ genome[ i:(i + k) ] ] = 1

  else:

    freq_table[ genome[ i:(i + k) ] ] += 1

count = 0



for kmer in dictionary:

  for key in freq_table.keys():

    if HammingDistance( kmer, key ) <= d:

      count += freq_table[ key ]

    if HammingDistance( ReverseComplement( kmer ) , key ) <= d:

      count += freq_table[ key ]

  new_freq_table[ kmer ] = count

  count = 0


max_value = max( new_freq_table.values() )

while True:


  try:
    max_element = max( new_freq_table, key=new_freq_table.get )

  except ValueError:
    break

  if new_freq_table[ max_element ] != max_value:
    break 

  print( max_element )

  new_freq_table.pop( max_element )

"""# Enumerating all possible DNA strings of length k and then comparing whether the gene matches with these strings within a Hamming distance of 1."""

genome = "AAA"

d = 1

k = len( genome )

freq_table = {}

new_freq_table = {}

alphabet = [ "A", "T", "C", "G" ]

dictionary = ["A" * k]

num = list( "0" * k )

len_alpha = len( alphabet )

g_length = len( genome )




def add( num, position ):

  if int( num[ position ] ) + 1 > len_alpha - 1:

    if position + 1 > k-1:
      return

    num[ position ] = '0'

    add( num, position + 1 )
    return

  num[ position ] = str( int( num[ position ] ) + 1  )

  kmer = []

  for i in range( len( num ) ):

    kmer.append( alphabet[int(num[i])] )

  dictionary.append( "".join(kmer) )
  


for i in range( len_alpha ** k ):

  if int( num[ 0 ] ) + 1 > len_alpha - 1:

    num[ 0 ] = '0'

    add( num, 1 )
  
  else:

    num[ 0 ] = str( int( num[ 0 ] ) + 1  )

    kmer = []

    for i in range( len( num ) ):

      kmer.append( alphabet[int(num[i])] )

    dictionary.append( "".join(kmer) )


count = 0

for word in dictionary:

  if HammingDistance(genome, word) <= d:
    count += 1
    print( word )


print( count )